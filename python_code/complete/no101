#!/usr/bin/env python

# LAGRANGE POLYNOMIAL FOR F:
# For data points (x_1, f(x_1))...(x_n, f(x_n))
# We have Lagrange base polynomials
# l_i(x) = prod_{j neq i} (x - x_j)/(x_i - x_j)
# L(x) = sum_i f(x_i) l_i(x)

# For our problem, we seek OP(n, n + 1), but this is
# L_n(n + 1) for L_n generated by the first n points
# x_i = i, with f given as 1 - n + n^2 ...

# If OP(n, n + 1) != f(n + 1), then we count the value
# We stop when n = 11

# f(x)(1 + x) = 1 + x^11

# We have L_n(n + 1) = sum_i f(i) l_i(n + 1)

import operator

from python_code.decorators import euler_timer

def lagrange(input_val, index, points):
    numerator = reduce(operator.mul, [input_val - points[i] for i in
                                      range(len(points)) if i != index])
    denominator = reduce(operator.mul, [points[index] - points[i] for i in
                                        range(len(points)) if i != index])
    return numerator*1.0/denominator

def n_value_approximation(func, n, input_val):
    if n == 1:
        return func(1)
    points = range(1, n + 1)
    return sum([func(points[i])*lagrange(input_val, i, points)
                for i in range(len(points))])

@euler_timer(101)
def main():
    def func(x):
        return ((1 + x**11)*(1.0))/(1 + x)
    result = 0
    for k in range(1, 11):
        val = n_value_approximation(func, k, k + 1)
        if val != func(k + 1):
            result += val
    print int(result)

if __name__ == "__main__":
    main()
